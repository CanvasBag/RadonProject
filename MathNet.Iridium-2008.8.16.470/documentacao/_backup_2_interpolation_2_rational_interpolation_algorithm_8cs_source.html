<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Matrix: I:/VSProjects/MathNet.Iridium-2008.8.16.470/Sources/Library/Backup/Interpolation/RationalInterpolationAlgorithm.cs Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="namespaces.html"><span>Packages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>I:/VSProjects/MathNet.Iridium-2008.8.16.470/Sources/Library/Backup/Interpolation/RationalInterpolationAlgorithm.cs</h1>  </div>
</div>
<div class="contents">
<a href="_backup_2_interpolation_2_rational_interpolation_algorithm_8cs.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="preprocessor">#region Math.NET Iridium (LGPL) by Ruegg + Contributors</span>
<a name="l00002"></a>00002 <span class="preprocessor"></span><span class="comment">// Math.NET Iridium, part of the Math.NET Project</span>
<a name="l00003"></a>00003 <span class="comment">// http://mathnet.opensourcedotnet.info</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// Copyright (c) 2002-2008, Christoph Rüegg, http://christoph.ruegg.name</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// Contribution: Numerical Recipes in C++, Second Edition [2003]</span>
<a name="l00008"></a>00008 <span class="comment">//               Handbook of Mathematical Functions [1965]</span>
<a name="l00009"></a>00009 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment">// This program is free software; you can redistribute it and/or modify</span>
<a name="l00011"></a>00011 <span class="comment">// it under the terms of the GNU Lesser General Public License as published </span>
<a name="l00012"></a>00012 <span class="comment">// by the Free Software Foundation; either version 2 of the License, or</span>
<a name="l00013"></a>00013 <span class="comment">// (at your option) any later version.</span>
<a name="l00014"></a>00014 <span class="comment">//</span>
<a name="l00015"></a>00015 <span class="comment">// This program is distributed in the hope that it will be useful,</span>
<a name="l00016"></a>00016 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00017"></a>00017 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00018"></a>00018 <span class="comment">// GNU Lesser General Public License for more details.</span>
<a name="l00019"></a>00019 <span class="comment">//</span>
<a name="l00020"></a>00020 <span class="comment">// You should have received a copy of the GNU Lesser General Public </span>
<a name="l00021"></a>00021 <span class="comment">// License along with this program; if not, write to the Free Software</span>
<a name="l00022"></a>00022 <span class="comment">// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<a name="l00023"></a>00023 <span class="preprocessor">#endregion</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span>
<a name="l00025"></a>00025 <span class="keyword">using</span> System;
<a name="l00026"></a>00026 <span class="keyword">using</span> MathNet.Numerics;
<a name="l00027"></a>00027 <span class="keyword">using</span> MathNet.Numerics.Properties;
<a name="l00028"></a>00028 
<a name="l00029"></a>00029 <span class="keyword">namespace </span>MathNet.Numerics.Interpolation
<a name="l00030"></a>00030 {
<a name="l00034"></a>00034     [Obsolete(<span class="stringliteral">&quot;Please use Interpolation or directly one of the newer implementation in the Algorithms namespace instead. The direct replacement is LimitedOrderRationalInterpolation. This class is obsolete and will be removed in future versions.&quot;</span>)]
<a name="l00035"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html">00035</a>     <span class="keyword">public</span> <span class="keyword">class </span><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html" title="Lagrange Rational Interpolation using Bulirsch &amp;amp; Stoer&amp;#39;s Algorithm.">RationalInterpolationAlgorithm</a> : <a class="code" href="interface_math_net_1_1_numerics_1_1_interpolation_1_1_i_interpolation_algorithm.html" title="Interpolation algorithm.">IInterpolationAlgorithm</a>
<a name="l00036"></a>00036     {
<a name="l00037"></a>00037         <a class="code" href="class_math_net_1_1_numerics_1_1_sample_list.html" title="SampleList is a sorted list in ascending order for discrete function samples x=f(t) or value pairs (t...">SampleList</a> _samples;
<a name="l00038"></a>00038         <span class="keywordtype">int</span> _maximumOrder;
<a name="l00039"></a>00039         <span class="keywordtype">int</span> _effectiveOrder;
<a name="l00040"></a>00040 
<a name="l00044"></a>00044         <span class="keyword">public</span>
<a name="l00045"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#aa88d129d198bf1413a18a02bd51acaf4">00045</a>         <a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html" title="Lagrange Rational Interpolation using Bulirsch &amp;amp; Stoer&amp;#39;s Algorithm.">RationalInterpolationAlgorithm</a>()
<a name="l00046"></a>00046         {
<a name="l00047"></a>00047             _maximumOrder = <span class="keywordtype">int</span>.MaxValue;
<a name="l00048"></a>00048             _effectiveOrder = -1;
<a name="l00049"></a>00049         }
<a name="l00050"></a>00050 
<a name="l00054"></a>00054         <span class="keyword">public</span>
<a name="l00055"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#a443526d7ddc11319bdd9a62e31329542">00055</a>         <a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html" title="Lagrange Rational Interpolation using Bulirsch &amp;amp; Stoer&amp;#39;s Algorithm.">RationalInterpolationAlgorithm</a>(
<a name="l00056"></a>00056             <span class="keywordtype">int</span> maximumOrder
<a name="l00057"></a>00057             )
<a name="l00058"></a>00058         {
<a name="l00059"></a>00059             _maximumOrder = maximumOrder;
<a name="l00060"></a>00060             _effectiveOrder = -1;
<a name="l00061"></a>00061         }
<a name="l00062"></a>00062 
<a name="l00066"></a>00066         <span class="keyword">public</span>
<a name="l00067"></a>00067         <span class="keywordtype">void</span>
<a name="l00068"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#ac534119be5ed45283dc89933255fdff7">00068</a>         Prepare(
<a name="l00069"></a>00069             <a class="code" href="class_math_net_1_1_numerics_1_1_sample_list.html" title="SampleList is a sorted list in ascending order for discrete function samples x=f(t) or value pairs (t...">SampleList</a> samples
<a name="l00070"></a>00070             )
<a name="l00071"></a>00071         {
<a name="l00072"></a>00072             <span class="keywordflow">if</span>(null == samples)
<a name="l00073"></a>00073             {
<a name="l00074"></a>00074                 <span class="keywordflow">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="stringliteral">&quot;samples&quot;</span>);
<a name="l00075"></a>00075             }
<a name="l00076"></a>00076 
<a name="l00077"></a>00077             _samples = samples;
<a name="l00078"></a>00078             _effectiveOrder = Math.Min(_maximumOrder, samples.<a class="code" href="class_math_net_1_1_numerics_1_1_sample_list.html#aac5fc9863832ab801fd617798c79f6e9" title="The count of unique samples stored.">Count</a>);
<a name="l00079"></a>00079         }
<a name="l00080"></a>00080 
<a name="l00085"></a>00085         <span class="keyword">public</span> <span class="keywordtype">int</span> MaximumOrder
<a name="l00086"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#a367dd2a197e39055ae2ccfc04d4d3db4">00086</a>         {
<a name="l00087"></a>00087             <span class="keyword">get</span>
<a name="l00088"></a>00088             {
<a name="l00089"></a>00089                 <span class="keywordflow">return</span> _maximumOrder;
<a name="l00090"></a>00090             }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092             <span class="keyword">set</span>
<a name="l00093"></a>00093             {
<a name="l00094"></a>00094                 <span class="keywordflow">if</span>(value &lt; 0)
<a name="l00095"></a>00095                 {
<a name="l00096"></a>00096                     <span class="keywordflow">throw</span> <span class="keyword">new</span> ArgumentOutOfRangeException(<span class="stringliteral">&quot;value&quot;</span>);
<a name="l00097"></a>00097                 }
<a name="l00098"></a>00098 
<a name="l00099"></a>00099                 <span class="keywordflow">if</span>(_maximumOrder == value)
<a name="l00100"></a>00100                 {
<a name="l00101"></a>00101                     <span class="keywordflow">return</span>;
<a name="l00102"></a>00102                 }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104                 <span class="keywordflow">if</span>(null == _samples)
<a name="l00105"></a>00105                 {
<a name="l00106"></a>00106                     _maximumOrder = value;
<a name="l00107"></a>00107                     _effectiveOrder = -1;
<a name="l00108"></a>00108                     <span class="keywordflow">return</span>;
<a name="l00109"></a>00109                 }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111                 _maximumOrder = value;
<a name="l00112"></a>00112                 _effectiveOrder = Math.Min(value, _samples.Count);
<a name="l00113"></a>00113             }
<a name="l00114"></a>00114         }
<a name="l00115"></a>00115 
<a name="l00120"></a>00120         <span class="keyword">public</span> <span class="keywordtype">int</span> EffectiveOrder
<a name="l00121"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#a541bfd633a399e780a11f75a69a6c45e">00121</a>         {
<a name="l00122"></a>00122             <span class="keyword">get</span> { <span class="keywordflow">return</span> _effectiveOrder; }
<a name="l00123"></a>00123         }
<a name="l00124"></a>00124 
<a name="l00128"></a>00128         <span class="keyword">public</span>
<a name="l00129"></a>00129         <span class="keywordtype">double</span>
<a name="l00130"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#adc19e3c8437098fc328ccbda8452e90c">00130</a>         Interpolate(
<a name="l00131"></a>00131             <span class="keywordtype">double</span> t
<a name="l00132"></a>00132             )
<a name="l00133"></a>00133         {
<a name="l00134"></a>00134             <span class="keywordtype">double</span> error;
<a name="l00135"></a>00135             <span class="keywordflow">return</span> Interpolate(t, out error);
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00141"></a>00141         <span class="keyword">public</span>
<a name="l00142"></a>00142         <span class="keywordtype">double</span>
<a name="l00143"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#a3aac5eb768062a1bff3612190de6648f">00143</a>         Interpolate(
<a name="l00144"></a>00144             <span class="keywordtype">double</span> t,
<a name="l00145"></a>00145             out <span class="keywordtype">double</span> error
<a name="l00146"></a>00146             )
<a name="l00147"></a>00147         {
<a name="l00148"></a>00148             <span class="keywordflow">if</span>(null == _samples)
<a name="l00149"></a>00149             {
<a name="l00150"></a>00150                 <span class="keywordflow">throw</span> <span class="keyword">new</span> InvalidOperationException(<a class="code" href="class_math_net_1_1_numerics_1_1_properties_1_1_resources.html" title="A strongly-typed resource class, for looking up localized strings, etc.">Resources</a>.InvalidOperationNoSamplesProvided);
<a name="l00151"></a>00151             }
<a name="l00152"></a>00152 
<a name="l00153"></a>00153             <span class="keyword">const</span> <span class="keywordtype">double</span> tiny = 1.0e-15;
<a name="l00154"></a>00154             <span class="keywordtype">int</span> closestIndex;
<a name="l00155"></a>00155             <span class="keywordtype">int</span> offset = SuggestOffset(t, out closestIndex);
<a name="l00156"></a>00156             <span class="keywordtype">double</span>[] c = <span class="keyword">new</span> <span class="keywordtype">double</span>[_effectiveOrder];
<a name="l00157"></a>00157             <span class="keywordtype">double</span>[] d = <span class="keyword">new</span> <span class="keywordtype">double</span>[_effectiveOrder];
<a name="l00158"></a>00158             <span class="keywordtype">int</span> ns = closestIndex - offset;
<a name="l00159"></a>00159             <span class="keywordtype">double</span> den, ho, hp;
<a name="l00160"></a>00160             <span class="keywordtype">double</span> x = 0;
<a name="l00161"></a>00161             error = 0;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163             <span class="keywordflow">if</span>(_samples.GetT(closestIndex) == t)
<a name="l00164"></a>00164             {
<a name="l00165"></a>00165                 <span class="keywordflow">return</span> _samples.GetX(closestIndex);
<a name="l00166"></a>00166             }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; _effectiveOrder; i++)
<a name="l00169"></a>00169             {
<a name="l00170"></a>00170                 c[i] = _samples.GetX(offset + i);
<a name="l00171"></a>00171                 d[i] = c[i] + tiny; <span class="comment">// prevent rare zero-over-zero condition</span>
<a name="l00172"></a>00172             }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174             x = _samples.GetX(offset + ns--);
<a name="l00175"></a>00175             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> level = 1; level &lt; _effectiveOrder; level++)
<a name="l00176"></a>00176             {
<a name="l00177"></a>00177                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; _effectiveOrder - level; i++)
<a name="l00178"></a>00178                 {
<a name="l00179"></a>00179                     hp = _samples.GetT(offset + i + level) - t;
<a name="l00180"></a>00180                     ho = (_samples.GetT(offset + i) - t) * d[i] / hp;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182                     den = ho - c[i + 1];
<a name="l00183"></a>00183                     <span class="keywordflow">if</span>(den == 0)
<a name="l00184"></a>00184                     {
<a name="l00185"></a>00185                         <span class="comment">// TODO (cdr, 2006-06-09): Check sign (positive or negative infinity?)</span>
<a name="l00186"></a>00186                         error = 0;
<a name="l00187"></a>00187                         <span class="keywordflow">return</span> <span class="keywordtype">double</span>.PositiveInfinity; <span class="comment">// or is it NegativeInfinity?</span>
<a name="l00188"></a>00188                     }
<a name="l00189"></a>00189 
<a name="l00190"></a>00190                     den = (c[i + 1] - d[i]) / den;
<a name="l00191"></a>00191                     d[i] = c[i + 1] * den;
<a name="l00192"></a>00192                     c[i] = ho * den;
<a name="l00193"></a>00193                 }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195                 error = (2 * (ns + 1) &lt; (_effectiveOrder - level) ? c[ns + 1] : d[ns--]);
<a name="l00196"></a>00196                 x += error;
<a name="l00197"></a>00197             }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199             <span class="keywordflow">return</span> x;
<a name="l00200"></a>00200         }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202         <span class="keywordtype">int</span>
<a name="l00203"></a>00203         SuggestOffset(
<a name="l00204"></a>00204             <span class="keywordtype">double</span> t,
<a name="l00205"></a>00205             out <span class="keywordtype">int</span> closestIndex
<a name="l00206"></a>00206             )
<a name="l00207"></a>00207         {
<a name="l00208"></a>00208             closestIndex = Math.Max(_samples.Locate(t), 0);
<a name="l00209"></a>00209             <span class="keywordtype">int</span> ret = Math.Min(
<a name="l00210"></a>00210                 Math.Max(
<a name="l00211"></a>00211                     closestIndex - (_effectiveOrder - 1) / 2,
<a name="l00212"></a>00212                     0
<a name="l00213"></a>00213                     ),
<a name="l00214"></a>00214                 _samples.Count - _effectiveOrder
<a name="l00215"></a>00215                 );
<a name="l00216"></a>00216 
<a name="l00217"></a>00217             <span class="keywordflow">if</span>(closestIndex &lt; (_samples.Count - 1))
<a name="l00218"></a>00218             {
<a name="l00219"></a>00219                 <span class="keywordtype">double</span> dist1 = Math.Abs(t - _samples.GetT(closestIndex));
<a name="l00220"></a>00220                 <span class="keywordtype">double</span> dist2 = Math.Abs(t - _samples.GetT(closestIndex + 1));
<a name="l00221"></a>00221 
<a name="l00222"></a>00222                 <span class="keywordflow">if</span>(dist1 &gt; dist2)
<a name="l00223"></a>00223                 {
<a name="l00224"></a>00224                     closestIndex++;
<a name="l00225"></a>00225                 }
<a name="l00226"></a>00226             }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228             <span class="keywordflow">return</span> ret;
<a name="l00229"></a>00229         }
<a name="l00230"></a>00230 
<a name="l00234"></a>00234         <span class="keyword">public</span>
<a name="l00235"></a>00235         <span class="keywordtype">double</span>
<a name="l00236"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#a280c05af615c8bb8c05226c9bdf226ee">00236</a>         Extrapolate(
<a name="l00237"></a>00237             <span class="keywordtype">double</span> t
<a name="l00238"></a>00238             )
<a name="l00239"></a>00239         {
<a name="l00240"></a>00240             <span class="keywordflow">return</span> Interpolate(t);
<a name="l00241"></a>00241         }
<a name="l00242"></a>00242 
<a name="l00249"></a>00249         <span class="keyword">public</span> <span class="keywordtype">bool</span> SupportErrorEstimation
<a name="l00250"></a><a class="code" href="class_math_net_1_1_numerics_1_1_interpolation_1_1_rational_interpolation_algorithm.html#a306fc0a2895f9b5249f8318db7917a8d">00250</a>         {
<a name="l00251"></a>00251             <span class="keyword">get</span> { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00252"></a>00252         }
<a name="l00253"></a>00253     }
<a name="l00254"></a>00254 }
</pre></div></div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sun Oct 17 2010 11:35:09 for Matrix by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
